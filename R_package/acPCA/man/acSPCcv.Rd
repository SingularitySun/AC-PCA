% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acSPCcv.R
\name{acSPCcv}
\alias{acSPCcv}
\title{Perform cross-validation to tune the sparsity parameter c2 in function acSPC}
\usage{
acSPCcv(X, Y, c1 = NULL, c2s, v_ini, v_substract = NULL, X4Y = NULL,
  kernel = c("linear", "gaussian"), bandwidth = NULL, centerX = T,
  centerY = T, scaleX = F, scaleY = F, maxiter = 25, delta = 10^-4,
  fold = 10, plot = T, quiet = F)
}
\arguments{
\item{X}{the n by p data matrix, where n is the number of samples, p is the number of variables. Missing values in X should be labeled as NA. If a whole sample in X is missing, it should be removed.}

\item{Y}{the n by q confounder matrix, where n is the number of samples, q is the number of confounding factors. Missing values in Y should be labeled as NA.}

\item{c1}{non-negative tuning parameter. Default is set to v_ini'X4Y'KX4Yv_ini. Optional.}

\item{c2s}{a vector of non-negative tuning parameters controlling sparsity.}

\item{v_ini}{the initial v. Recommended to be the estimate of the non-sparse version.}

\item{v_substract}{the principal components to be subtracted. A p by k matrix, where k is the number of PCs to be substracted. Optional.}

\item{X4Y}{the "X" used to calculate the empirical Hilbert Schmidt criterion. Default is set to X. Optional.}

\item{kernel}{the kernel to use: "linear", "gaussian".}

\item{bandwidth}{bandwidth h for Gaussian kernel. Optional.}

\item{centerX}{center the columns in X. Default is True.}

\item{centerY}{center the columns in Y. Default is True.}

\item{scaleX}{scale the columns in X to unit standard deviation. Default is False.}

\item{scaleY}{scale the columns in Y to unit standard deviation. Default is False.}

\item{fold}{the fold number for cross-validation. Default is 10.}

\item{plot}{True or False. plot=T generates the c2 vs. mean squared error(MSE) plot. Default is True.}

\item{quiet}{True or False. Output the progress of the program. Default is False.}

\item{...}{other parameters}
}
\value{
Results for tuning the sparsity parameter c2
\item{mse}{a vector of MSEs for c2s. Mean is taken for the sum of squared errors in each fold.} 
\item{c2s}{the input c2s}
\item{best_c2}{c2 with the smallest MSE}
\item{mse_sd}{a vector of standard deviations for the MSEs. Standard deviation across the folds is calculated.}
}
\description{
Perform cross-validation to tune the sparsity parameter c2 in function acSPC
}
\examples{
load_all()
data(data_brain_w2)
X <- data_brain_w2$X; Y <- data_brain_w2$Y
### we first tune lambda
result_tune <- acPCAtuneLambda(X=X, Y=Y, nPC=2, lambdas=seq(0, 20, 0.05),
                             anov=T, kernel = "linear", quiet=T)
result <- acPCA(X=X, Y=Y, lambda=result_tune$best_lambda, kernel="linear", nPC=2)
### the initial v
v_ini <- as.matrix(result$v[,1])
### a coarse search first
c2s <- seq(1, 0, -0.1)*sum(abs(v_ini))
resultcv_spc1_coarse <- acSPCcv( X=X, Y=Y, c2s=c2s, v_ini=v_ini,
                                 kernel="linear", quiet=T, fold=10)
### a fine search
c2s <- seq(0.9, 0.7, -0.02)*sum(abs(v_ini))
resultcv_spc1_fine <- acSPCcv( X=X, Y=Y, c2s=c2s, v_ini=v_ini,
                               kernel="linear", quiet=T, fold=10)
result_spc1 <- acSPC( X=X, Y=Y, c2=resultcv_spc1_fine$best_c2,
                      v_ini=v_ini, kernel="linear")
}

